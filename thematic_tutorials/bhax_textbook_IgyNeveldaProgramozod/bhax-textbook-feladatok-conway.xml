<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Mm1g9llfe7Q">https://youtu.be/Mm1g9llfe7Q</link>
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Conway/hangya/ant.h">ant.h</link>, <link xlink:href="src/Conway/hangya/antthread.cpp">antthread.cpp</link>, 
            <link xlink:href="src/Conway/hangya/antthread.h">antthread.h</link>, <link xlink:href="src/Conway/hangya/antwin.cpp">antwin.cpp</link>, 
            <link xlink:href="src/Conway/hangya/antwin.h">antwin.h</link>, <link xlink:href="src/Conway/hangya/main.cpp">main.cpp</link>, 
            <link xlink:href="src/Conway/hangya/myrmecologist.pro">myrmecologist.pro</link>               
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
#ifndef ANT_H
#define ANT_H
class Ant {
public:
    int x;
    int y;
    int dir;
    
    Ant(int x, int y): x(x), y(y){
        dir =qrand() % 8;
    };
    typedef std::vector<Ant> Ants;
    #endif]]></programlisting>
        </para>
        <para>
            Az Ant osztályban szerepelnek a hangya tulajdonságai. Az ant.h-ban található a sor/oszlop/irány változója, valamint ugyanitt található egy random függvény, ami az irányhoz 0 
            és 8 között véletlenszerűen rendel egy számot. Az Ants nevű vektorban lesznek elhelyezve a hangyák.
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
AntWin(int width = 100, int height = 75,
       int delay = 120, int numAnts = 100,
       int pheromone = 10, int nbhPheromon = 3,
       int min = 2, int max = 50,
       int cellAntMax = 4, QWidget *parent = 0);)]]></programlisting>
        </para>
        <para>
            Itt találhatóak az osztály tulajdonságai. Itt definiáljuk, hogy milyen magas és milyen széles legyen az ablak (cellákban).
        </para>
        <para>
            A grids: int*** két rácsra mutat. Ha csak egy van, akkor egy hangya lép, és ezzel megváltoztatja a feromon eloszlását, a második 
            már ez alapján a feromon alapján hozza meg a következő döntését és így tovább... Ha két rács van, akkor az elsőn azt nézzük, hogy hova 
            lép a hangya, a másodikon pedig a feromont. A gridIdx segítségével döntjük el, hogy a nulladik, vagy az első rácsot választjuk. 
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
void AntWin::paintEvent ( QPaintEvent* ) {
    QPainter qpainter ( this );
    grid = grids[gridIdx];
    for ( int i=0; i<height; ++i ) {
        for ( int j=0; j<width; ++j ) {
            double rel = 255.0/max;
            qpainter.fillRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight,
                                QColor ( 255 - grid[i][j]*rel,
                                         255,
                                         255 - grid[i][j]*rel) );
                                    1)
                                );
                                qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                                    cellWidth, cellHeight );
                            }
                            qpainter.setPen(
                                WPen(
                                    QColor(0,0,0),
                                    1)
                            );
                            qpainter.drawRect(j*cellWidth, i*cellHeight,
                                              cellWidth, cellHeight);
                        }
                    }
                    for (auto h: *ants)
                    {
                        qpainter.setPen(QPen(Qt::black, 1));
                        qpainter.drawRect(h.x*cellWidth+1, h.y*cellHeight+1,
                                          cellWidth-2, cellHeight-2);
                    }
                    qpainter.end();
                }]]></programlisting>
        </para>
        <para>
            Ez for ciklusok segítségével színezi a megfelelő cellákat, ezzel reprezentálva a hangyákat. A QPen segítségével állíthatjuk be a szít és a vastagságot. 
        </para>
        <para>
            <programlisting language="c++"><![CDATA[
//AntWin.h
    void closeEvent ( QCloseEvent *event ) {
        antThread->finish();
        antThread->wait();
        event->accept();
    }
    
//AntThread.h

void finish(){
    running = false;
}]]></programlisting>
        </para>
        <para>
            A closeEvent() függvény felelős a szál megállításáért, valamint a program bezárásáért. A finish() a runningot hamisra állítja, ezáltal leáll a futása. 
        </para>
        <para>
            Az UML (Unified Modeling Language) egy általános célú modellező nyelv, ideális objektum orientált programok szemléletes leírására. A Kolónia (AntThread) egy QThread osztályból 
            származtatott osztály, mivel a számításokat a main threadtől, ami a GUI-t kezeli, el akarjuk különíteni, így nem fagy le az ablak. Ez a boly végzi a hangyák mozgatását, 
            alkalmaztatja a környezetre a hangyák által kibocsátott feromonokat. Az AntWin  a világot kezeli, ezen felül különböző funkciókat ad a programhoz: a rács, valamint az egyes 
            zónák a világon (cellák) berajzolása. Az össze megjelenített tartalmat, valamint a GUI eseményeket is kezeli, amiket lekövetünk. Alább látható a hangyaszimulációról 
            készített UML osztálydiagram:
        </para>
        <para>
            <mediaobject>
                <imageobject>
                        <imagedata fileref="img/Conway/uml.png" scale="50"/>
                </imageobject>
            </mediaobject>
        </para>
    </section>  

    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_haXQEn1vGU">https://youtu.be/_haXQEn1vGU</link> 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="src/Conway/Sejtautomata.java">Sejtautomata.java</link>          
        </para>
        <para>
            John Conway, angol matematikus, a fejezet címadója az életjátékot. A neve megtévesztő, ugyanis nem klasszikus értelemben vett játék, sokkal inkább egyfajta szimuláció. Egy 
            négyzetrácsos terület reprezentálja az életteret, minden egyes cellában pedig sejtek jelenhetnek meg. 3 nagyon egyszerű szabállyal igen komplex szituációkat lehet kreálni. 
        </para>
        <para>
            A 3 szabály: Egy sejt 2 vagy 3 szomszéddal életben marad. Ha ennél kevesebb, vagy túlnépesedik (ennél több szomszédja van), akkor elpusztul. Egy sejt akkor születik, ha 
            pontosan 3 élő szomszédja van. Ezen felül különböző standard, dinamikus alakzatok jelenhetnek meg (a videóban igyekeztem szemléltetni párat). 
        </para>            
        <para>
            Ebben a feladatban egy siklókilövőt kell kreálni, ami minden körben folyamatosan létrehoz sejteket, és azokat kilövi az élettérbe. Ezen felül a Java-s implementációban 
            rajzolni is tudunk, így mi magunk is létrehozhatunk különböző sejteket. 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public class Sejtautomata extends java.awt.Frame implements Runnable {
    /** Egy sejt lehet élő */
    public static final boolean ÉLŐ = true;
    /** vagy halott */
    public static final boolean HALOTT = false;
    /** Két rácsot használunk majd, az egyik a sejttér állapotát
     * a t_n, a másik a t_n+1 időpillanatban jellemzi. */
    protected boolean [][][] rácsok = new boolean [2][][];
    /** Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
     * [2][][]-ból az első dimenziót használni, mert vagy az egyikre
     * állítjuk, vagy a másikra. */
    protected boolean [][] rács;
    /** Megmutatja melyik rács az aktuális: [rácsIndex][][] */
    protected int rácsIndex = 0;
    /** Pixelben egy cella adatai. */
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    /** A sejttér nagysága, azaz hányszor hány cella van? */
    protected int szélesség = 20;
    protected int magasság = 10;
    /** A sejttér két egymást követő t_n és t_n+1 diszkrét időpillanata
     közötti valós idő. */  
    protected int várakozás = 1000;
    // Pillanatfelvétel készítéséhez
    private java.awt.Robot robot;
    /** Készítsünk pillanatfelvételt? */
    private boolean pillanatfelvétel = false;
    /** A pillanatfelvételek számozásához. */
    private static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy <code>Sejtautomata</code> objektumot.
     *
     * @param      szélesség    a sejttér szélessége.
     * @param      magasság     a sejttér szélessége.
     */
    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        // A két rács elkészítése
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        // A kiinduló rács minden cellája HALOTT
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        // A kiinduló rácsra "élőlényeket" helyezünk
        //sikló(rács, 2, 2);
        siklóKilövő(rács, 5, 60);
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });]]></programlisting>
        </para>
        <para>
            Ez itt a konstruktor. A Kommentek és a változónevek magukért beszélnek. Érdekesség, hogy található itt egy Robot osztály, amit főleg alkalmazások tesztelésére használnak. Képes 
            kezelni a billentyűzet -és egérmegszakításokat.
        </para>
        <para>
            <programlisting language="java"><![CDATA[
// A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            //A 'k', 'n', 'l', 'g' és 's' gombok lenyomását figyeljük
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    //Felezzük a cella méreteit:
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    //Duplázzuk a cella méreteit:
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
        //Egérkattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            //Egérkattintással jelöljük ki a nagyítandó területet
            //Bal felső sarkát vagy ugyancsak egér kattintással
            //Vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });
        //Egérmozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            //Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });]]></programlisting>
        </para>
        <para>
            Ezek az eseménykezelő függvények, amelyek segítségével különböző funkciókat tudunk életrekelteni a program futtatása során. Az 's' karakter lenyomásával pillanatképet 
            készíthetünk, a 'k' lenyomásával kicsinyíteni tudjuk a világunkat, ezáltal nagyobb területet felfedve, az 'n' billentyűvel pedig nagyíthatunk rajta. A 'g' gombbal gyorsítani, 
            az 'l'-el pedig lassítani tudjuk a szimulációt. A kattintást, valamint a vonszolást is kezeljük, a kattintás helyén új sejt jön létre.
        </para>
        <para>
            <programlisting language="java"><![CDATA[
   /** A sejttér kirajzolása. */
    public void paint(java.awt.Graphics g) {
        //Az aktuális
        boolean [][] rács = rácsok[rácsIndex];
        //Rácsot rajzoljuk ki:
        for(int i=0; i<rács.length; i++) { //végig lépked a sorokon
            for(int j=0; j<rács[0].length; j++) { //s az oszlopok
                //Sejtcella kirajzolása
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                //Rács kirajzolása
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }
        //Ha készült pillanatkép
        if(pillanatfelvétel) {
            /* a biztonság kedvéért egy kép készítése után
                kikapcsoljuk a pillanatfelvételt, hogy a
                programmal ismerkedő Olvasó ne írja tele a
                fájlrendszerét a pillanatfelvételekkel*/
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
    /**
      Az kérdezett állapotban lévő nyolcszomszédok száma.
    * 
    *    @param   rács    a sejttér rács
    *   @param   sor     a rács vizsgált sora
    *   @param   oszlop  a rács vizsgált oszlopa
    *    @param   állapor a nyolcszomszédok vizsgált állapota
    *    @return int a kérdezett állapotbeli nyolcszomszédok száma.
     */
    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        // A nyolcszomszédok végigzongorázása:
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                // A vizsgált sejtet magát kihagyva:
                if(!((i==0) && (j==0))) {
            // A sejttérből szélének szomszédai
            // a szembe oldalakon ("periódikus határfeltétel")
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }]]></programlisting>
        </para>
        <para>
            Berajzoljuk a fehér, illetve a fekete cellákat. Előbbi a halott, utóbbi az élő sejteket szimbolizálja. A SzomszédokSzáma függvényre azért van szükségünk, mert az algoritmus a 
            sejt élő szomszédjainak száma alapján működik. Kezeljük az olyan helyzeteket is, amikor a sejt egy szomszédja kilóg az élettérből (ilyenkor az átellenes pontban lévő sejtet 
            vizsgálja). 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                /* Élő élő marad, ha kettő vagy három élő
                 szomszedja van, különben halott lesz. */
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                /* Halott halott marad, ha három élő
                 szomszedja van, különben élő lesz. */
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
    /** A sejttér időbeli fejlődése. */
    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
    
    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }]]></programlisting>
        </para>
        <para>
            Az életjáték szabályainak implementálása a kódba. Két négyzetrácsos élettérre lesz szükségünk, hiszen az elsőből alakítjuk ki a következő iterációban látható életteret. 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }
    /** Pillanatfelvételek készítése. */
    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        // A pillanatfelvétel kép fájlneve
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).    
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
    /**
     * Példányosít egy Conway-féle életjáték szabályos
     * sejttér obektumot.
     */    
    public static void main(String[] args) {
        // 100 oszlop, 75 sor mérettel:
        new Sejtautomata(100, 75);
    }
}]]></programlisting>
        </para>
        <para>
            A siklókilövőt sejtenként kirajzoljuk a rácsba. Ezután dinamikussá tesszük az által, hogy a mozgását  is beleégetjük a rácsba
        </para>
    </section>        

    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gSSqilLDih0">https://youtu.be/gSSqilLDih0</link>
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Conway/game/main.cpp">main.cpp</link>, <link xlink:href="src/Conway/game/sejtablak.cpp">sejtablak.cpp</link>, 
            <link xlink:href="src/Conway/game/sejtszal.cpp">sejtszal.cpp</link>, <link xlink:href="src/Conway/game/sejtablak.h">sejtablak.h</link>, <link xlink:href="src/Conway/game/sejtszal.h">sejtszal.h</link>, 
            <link xlink:href="src/Conway/game/Sejtauto.pro">Sejtauto.pro</link>               
        </para>
        <para>
            Érdekesség a játékról, hogy az 1970-es évek egyik legnagyobb vírusának tartották a játékot, ami megosztó volt a közönség számára.Voltak olyanok, akik napi szinten használták a 
            játékot, míg voltak olyanok, akik nem értették, mégis miért jó ez a játék, mi a szórakoztató abban, hogy csak figyelni lehet a képernyőt. Ebben az időben lényegében 
            "szenvedélybetegséggé" vált a játék, a Time becslése szerint pedig több millió dolláros anyagi kárt okozott a biztosítótársaságoknak és a bankoknak, hiszen ezzel a gépidőből 
            veszítettek. A kutatóintézetekben is mindenki az egymást követő generációkat figyelte a monitorokon, szinte megbénítva az életet.
        </para>            
        <para>  
            Mivel a program nagyon hasonló az előzőhöz viszonyítva, így erről kevesebb szót ejtenék. Itt nem lesz lehetőségünk az egérrel új sejteket létrehozni, valamint gyorsbillentyűket 
            sem tudunk használni extra funkciókhoz. Csak egy egyszerű siklókilövő.
        </para>
        <para>  
            A sejtablak.cpp-ben először megadjuk az ablak magasságát, a szélességét, a feliratot, a benne lévő cellák nagyságát (6x6), és két for ciklus használatával létrehozunk új 
            cellákat, és a paramétereket megadjuk minden cellának.
        </para>
        <para>  
            <programlisting language="c++"><![CDATA[
racsok = new bool**[2];
racsok[0] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
racsok[0][i] = new bool [szelesseg];
racsok[1] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
racsok[1][i] = new bool [szelesseg];           
]]></programlisting>
        </para>
        <para>  
            Alapból minden cella fehér, tehát halott sejtek borítják. A paintEvent eljárás kirajzolja a cellákat 2 for ciklus segítségével, ha élő a sejt. Vagyis ha él, akkor feketére 
            színezi az adott cellát, ellenkező esetben fehér marad. Ebben a forráskódban található még az ablak törlése, valamint a sikló is, ami önmagát másolja, miközben halad a kilövés 
            irányába. A végén található maga a kilövő, aminek megjelenítésére az egyszerűség kedvéért előre megmondjuk, mely cellákat színezze be feketére, vagyis melyek legyenek élők.
        </para>
        <para>  
            A sejtszal.cpp-ben deklaráljuk a sejtszálat, valamint itt ellenőrizzük, hogy az adott sejtnek milyen szomszédai vannak. Végigmegyünk a szomszédokon és az oszlopszámhoz hozzáadunk/kivonunk
            1-et. Amennyiben negatív számot kapunk, az o változónk szélesség -1 lesz, ha pedig nagyobb, mint a szélességünk, akkor 0. Ezt megnézzük s-re is, és a kapott számokat betöltjük 
            az allapotuSzomszed változóba.
        </para>
        <para>  
            <programlisting language="c++"><![CDATA[
int allapotuSzomszed = 0;
for(int i=-1; i<2; ++i)
    for(int j=-1; j<2; ++j)
        if(!((i==0) && (j==0))) {
            int o = oszlop + j;
            if(o < 0)
                o = szelesseg-1;
            else if(o >= szelesseg)
                o = 0;

            int s = sor + i;
            if(s < 0)
                s = magassag-1;
            else if(s >= magassag)
                s = 0;
            if(racs[s][o] == allapot)
                allapotuSzomszed++;
}]]></programlisting>
        </para>
        <para>
            Az idoFejlodes eljárással végigmegyünk minden soron és oszlopon, megnézzük a rácsok szomszédjait és az élő sejt élő marad, ha kettő vagy három élő szomszédja van, egyébként 
            meghal. A halott halott marad, ha három élő szomszédja van, egyébként élővé válik. Ezután még deklaráljuk a run() eljárást, amiben egy végtelen ciklust használunk, hogy a 
            program örökké fusson, és az msleep használatával a várakozási időt felhasználva rávesszük a programot, hogy megfelelő időközönként frissítse az ablakot.
        </para>
    </section>    

    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/esport-talent-search">https://github.com/nbatfai/esport-talent-search</link>               
        </para>
        <para>
            A BrainB lényegében egy Benchmark program, amely az agy kognitív képességeit próbálja mérni. Az
            alapprobléma abból indult, hogy a legtöbb online kompetitív multiplayer játékban (különösen a
            MOBA-kban) gyakran előfordul, hogy egy teamfightban annyira sok vizuális tartalom jelenik meg a
            képernyőn egy időben, hogy egyszerűen nem tudjuk követni azokat, elveszítjük a karakterünket. A
            kognitív képességeink közé tartozik a szemünk által észlelt dolgok és események feldolgozása,
            azokból a hasznos információk leszűrése. Ezt a helyzetet igyekszik szimulálni a program.
        </para>    
        <para>
            A programot megnyitva különböző jelzésű négyzeteket láthatunk, mindegyikben egy sötét ponttal. A
            feladatunk az, hogy a Samu Entropy nevű négyzet pontjában tartsuk az egérmutatónkat lenyomva 10
            percig. Idő közben ezekből a négyzetekből egyre több lesz, valamint maguk az alakzatok
            mindeközben mozognak is (rezegnek/vibrálnak). Minél tovább tartjuk a helyes pontban az egerünket,
            annál több ilyen rezgő alakzat lesz látható a képernyőn, valamint egyre agresszívabban fogják a
            pozíciójukat változtatni. A 10 perc letelte után kapunk egy összesítő eredményjelző táblát, aminek az
            alján kiírja az agyam kognitív képességének a „számszerűsített” értékét Kbyte-ban. Alább látható az
            eredményem:
        </para>
        <para>
            <mediaobject>
                <imageobject>
                        <imagedata fileref="img/Conway/brainb.jpg" scale="35"/>
                </imageobject>
            </mediaobject>
        </para>        
    </section>        

    <section>
        <title>Minecraft MALMÖ Vörös Pipacs Pokol 19RF</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/VP0kfvRYD1Y">https://youtu.be/VP0kfvRYD1Y</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="src/Conway/pipacs.py">pipacs.py</link>
        </para>
        <para>
            <programlisting language="python"><![CDATA[
from __future__ import print_function
# ------------------------------------------------------------------------------------------------
# Copyright (c) 2016 Microsoft Corporation
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# ------------------------------------------------------------------------------------------------

# Tutorial sample #2: Run simple mission using raw XML

# Added modifications by Norbert Bátfai (nb4tf4i) batfai.norbert@inf.unideb.hu, mine.ly/nb4tf4i.1
# 2018.10.18, https://bhaxor.blog.hu/2018/10/18/malmo_minecraft
# 2020.02.02, NB4tf4i's Red Flowers, http://smartcity.inf.unideb.hu/~norbi/NB4tf4iRedFlowerHell
# 2020.03.02, https://github.com/nbatfai/RedFlowerHell
# 2020.03.07, "_smartSteve": nof_turn (number of turns) is replaced by the dict self.collectedFlowers 
# 2020.03.11, "_bu": bottom up, s4v3: https://youtu.be/VP0kfvRYD1Y

from builtins import range
import MalmoPython
import os
import sys
import time
import random
import json
import math

if sys.version_info[0] == 2:
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  # flush print output immediately
else:
    import functools
    print = functools.partial(print, flush=True)

# Create default Malmo objects:

agent_host = MalmoPython.AgentHost()
try:
    agent_host.parse( sys.argv )
except RuntimeError as e:
    print('ERROR:',e)
    print(agent_host.getUsage())
    exit(1)
if agent_host.receivedArgument("help"):
    print(agent_host.getUsage())
    exit(0)

# -- set up the mission -- #
missionXML_file='nb4tf4i_d.xml'
with open(missionXML_file, 'r') as f:
    print("NB4tf4i's Red Flowers (Red Flower Hell) - DEAC-Hackers Battle Royale Arena\n")
    print("NB4tf4i vörös pipacsai (Vörös Pipacs Pokol) - DEAC-Hackers Battle Royale Arena\n")
    print("The aim of this first challenge, called nb4tf4i's red flowers, is to collect as many red flowers as possible before the lava flows down the hillside.\n")
    print("Ennek az első, az nb4tf4i vörös virágai nevű kihívásnak a célja összegyűjteni annyi piros virágot, amennyit csak lehet, mielőtt a láva lefolyik a hegyoldalon.\n")    
    print("Norbert Bátfai, batfai.norbert@inf.unideb.hu, https://arato.inf.unideb.hu/batfai.norbert/\n")
    print("Version history\n", "Code: ", sys.argv[0], ", series 4 v.3, bottom up, max 18 poppies. Norbert Bátfai, nbatfai@gmail.com\n")
    print("Loading mission from %s" % missionXML_file)
    mission_xml = f.read()
    my_mission = MalmoPython.MissionSpec(mission_xml, True)
    my_mission.drawBlock( 0, 0, 0, "lava")

class Hourglass:
    def __init__(self, charSet):
        self.charSet = charSet
        self.index = 0
    def cursor(self):
        self.index=(self.index+1)%len(self.charSet)
        return self.charSet[self.index]

hg = Hourglass('|/-\|')

class Steve:
    def __init__(self, agent_host):
        self.agent_host = agent_host
        
        self.x = 0
        self.y = 0
        self.z = 0
        self.yaw = 0
        self.pitch = 0
        
        self.front_of_me_idx = 0
        self.front_of_me_idxr = 0
        self.front_of_me_idxl = 0        
        self.right_of_me_idx = 0
        self.left_of_me_idx = 0        
        
        self.nof_red_flower = 0
        self.lookingat = ""
        self.attackLvl = 0
        
        self.collectedFlowers = {}
        for i in range(100):
            self.collectedFlowers[i] = False

        self.collectedFlowers[1] = True
        self.collectedFlowers[2] = True

    def checkInventory(self, observations):
        for i in range(2):
            hotbari = 'Hotbar_'+str(i)+'_item'
            hotbars = 'Hotbar_'+str(i)+'_size'
            slot0_contents = observations.get(hotbari, "")
            if slot0_contents == "red_flower":
                slot0_size = observations.get(hotbars, "")
                if self.nof_red_flower < slot0_size :
                    self.nof_red_flower = slot0_size                                            
                    print("            A RED FLOWER IS MINED AND PICKED UP")
                    print("            Steve's lvl: ", self.y, "Flower lvl: ", self.attackLvl) 
                    self.collectedFlowers[self.attackLvl] = True
                    self.agent_host.sendCommand( "look -1" )
                    time.sleep(.4)
                    if self.lvlUp(observations.get("nbr3x3", 0)):
                        return True
    def pickUp(self):
        self.agent_host.sendCommand( "attack 1" )
        time.sleep(.23)
        self.attackLvl = self.y

    def lvlUp(self, nbr):
        if self.collectedFlowers[self.y]:
            self.turnToWall(nbr)
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.2)                
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.2)
            return True
        else:
            return False

    def idle(self, delay):
        #print("      SLEEPING for ", delay)
        time.sleep(delay)
                                                        
    def isInTrap(self, nbr):
            
        dc = 0    
        nbri = [9,10,11,12,14,15,16,17]    
        for i in range(1, len(nbri)):
            if nbr[nbri[i]]=="dirt" :
                dc = dc + 1            
        return dc > 5
    
    def turnFromWall(self, nbr):
        if (nbr[self.right_of_me_idx+9]=="air" and nbr[self.left_of_me_idx+9]=="dirt") or (nbr[self.right_of_me_idx]=="air" and nbr[self.left_of_me_idx]=="dirt"):
            self.agent_host.sendCommand( "turn 1" )
        else:
            self.agent_host.sendCommand( "turn -1" )
        time.sleep(.2)

    def turnToWall(self, nbr):
        if (nbr[self.right_of_me_idx+9]=="air" and nbr[self.left_of_me_idx+9]=="dirt") or (nbr[self.right_of_me_idx]=="air" and nbr[self.left_of_me_idx]=="dirt"):
            self.agent_host.sendCommand( "turn -1" )
        else:
            self.agent_host.sendCommand( "turn 1" )
        time.sleep(.2)

    def calcNbrIndex(self):
        if self.yaw >= 180-22.5 and self.yaw <= 180+22.5 :
            self.front_of_me_idx = 1
            self.front_of_me_idxr = 2
            self.front_of_me_idxl = 0
            self.right_of_me_idx = 5
            self.left_of_me_idx = 3            
        elif self.yaw >= 180+22.5 and self.yaw <= 270-22.5 :
            self.front_of_me_idx = 2 
            self.front_of_me_idxr = 5
            self.front_of_me_idxl =1             
            self.right_of_me_idx = 8
            self.left_of_me_idx = 0            
        elif self.yaw >= 270-22.5 and self.yaw <= 270+22.5 :
            self.front_of_me_idx = 5
            self.front_of_me_idxr = 8
            self.front_of_me_idxl = 2
            self.right_of_me_idx = 7
            self.left_of_me_idx = 1                        
        elif self.yaw >= 270+22.5 and self.yaw <= 360-22.5 :
            self.front_of_me_idx = 8            
            self.front_of_me_idxr = 7
            self.front_of_me_idxl = 5          
            self.right_of_me_idx = 6
            self.left_of_me_idx = 2                        
        elif self.yaw >= 360-22.5 or self.yaw <= 0+22.5 :
            self.front_of_me_idx = 7
            self.front_of_me_idxr = 6
            self.front_of_me_idxl = 8
            self.right_of_me_idx = 3
            self.left_of_me_idx = 5                        
        elif self.yaw >= 0+22.5 and self.yaw <= 90-22.5 :
            self.front_of_me_idx = 6
            self.front_of_me_idxr = 3
            self.front_of_me_idxl = 7          
            self.right_of_me_idx = 0
            self.left_of_me_idx = 8                        
        elif self.yaw >= 90-22.5 and self.yaw <= 90+22.5 :
            self.front_of_me_idx = 3
            self.front_of_me_idxr = 0
            self.front_of_me_idxl = 6
            self.right_of_me_idx = 1
            self.left_of_me_idx = 7                        
        elif self.yaw >= 90+22.5 and self.yaw <= 180-22.5 :
            self.front_of_me_idx = 0
            self.front_of_me_idxr = 1
            self.front_of_me_idxl = 3
            self.right_of_me_idx = 2
            self.left_of_me_idx = 6                        
        else:
            print("There is great disturbance in the Force...")            

    def whatISee(self, observations):
        self.lookingat = "NOTHING"            
        if "LineOfSight" in observations:
            lineOfSight = observations["LineOfSight"] 
            self.lookingat = lineOfSight["type"]      

    def whatMyPos(self, observations):
        if "Yaw" in observations:
            self.yaw = int(observations["Yaw"])
        if "Pitch" in observations:
            self.pitch = int(observations["Pitch"])
        if "XPos" in observations:
            self.x = int(observations["XPos"])
        if "ZPos" in observations:
            self.z = int(observations["ZPos"])        
        if "YPos" in observations:
            self.y = int(observations["YPos"])        
            
    def run(self):
        world_state = self.agent_host.getWorldState()
        # Loop until mission ends:
        while world_state.is_mission_running:
            
            #print(">>> nb4tf4i arena -----------------------------------\n")
            act = self.action(world_state)
            #print("nb4tf4i arena >>> -----------------------------------\n")
            if not act:
                self.idle(.017)
            world_state = self.agent_host.getWorldState()

    def action(self, world_state):
        for error in world_state.errors:
            print("Error:", error.text)
        
        if world_state.number_of_observations_since_last_state == 0:
            #print("    NO OBSERVATIONS NO ACTIONS")
            return False
        
        input = world_state.observations[-1].text
        observations = json.loads(input)
        nbr = observations.get("nbr3x3", 0)
        #print(observations)
        
        self.whatMyPos(observations)
        print("\r    Steve's Coords: ", self.x, self.y, self.z, end='')        
        #print("    Steve's Yaw: ", self.yaw)        
        #print("    Steve's Pitch: ", self.pitch)        

        self.checkInventory(observations)
        #print("Number of flowers: ", self.nof_red_flower)

        self.whatISee(observations)
        #print("    Steve's <): ", self.lookingat)
                        
        self.calcNbrIndex()                
                        
        if self.isInTrap(nbr) :
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.1)
            self.turnFromWall(nbr)
            self.agent_host.sendCommand( "jumpmove 1" )
            time.sleep(.1)            
            return True

        if self.lookingat == "red_flower":
            print(" A RED FLOWER IS FOUND (lookingat)")
            self.pickUp()
            return True
        
        for i in range(9):
            if nbr[i]=="red_flower" or nbr[i+9]=="red_flower" or nbr[i+18]=="red_flower":
                print("        I CAN SEE A RED FLOWER: ", i, " LEVEL ", self.y)
                if i == self.front_of_me_idx :
                    print("F            A RED FLOWER IS RIGTH IN FRONT OF ME")
                    self.agent_host.sendCommand( "move 1" )
                    time.sleep(.2)
                    self.agent_host.sendCommand( "look 1" )
                    time.sleep(.2)
                    print("Steve <) ", self.lookingat)
                    return True
                elif i == self.front_of_me_idxr :
                    print("R            A RED FLOWER IS RIGTH IN RIGHT OF ME")
                    self.agent_host.sendCommand( "strafe 1" )
                    time.sleep(.2)
                    return True
                elif i == self.front_of_me_idxl :
                    print("L            A RED FLOWER IS RIGTH IN LEFT OF ME")
                    self.agent_host.sendCommand( "strafe -1" )
                    time.sleep(.2)
                    return True
                elif i == 4  :
                    self.red_flower_is_mining = True
                    print("            I AM STANDING ON A RED FLOWER!!!")
                    
                    if self.pitch != 90:
                        self.agent_host.sendCommand( "look 1" )
                        print("PITCH            I AM STANDING ON A RED FLOWER!!!")
                        time.sleep(.3)
                    else:
                        print("ATTACK            I AM STANDING ON A RED FLOWER!!! LEVEL ", self.y)
                        self.pickUp()
                        self.agent_host.sendCommand( "look -1" )
                        time.sleep(.3)
                    return True
                
                else :
                    print("            I AM TURNING TO A RED FLOWER")
                    self.agent_host.sendCommand( "turn 1" )
                    time.sleep(.2)
                    return True
  
        if self.lvlUp(nbr):
            print("        LVL UP")

        if nbr[self.front_of_me_idx+9]!="air" and nbr[self.front_of_me_idx+9]!="red_flower":
            print("        THERE ARE OBSTACLES IN FRONT OF ME ",  nbr[self.front_of_me_idx], end='')
  
            self.turnFromWall(nbr)
                        
        else:
            print("        THERE IS NO OBSTACLE IN FRONT OF ME", end='')
            
            if nbr[self.front_of_me_idx]=="dirt":
                self.agent_host.sendCommand( "move 1" )
                time.sleep(.013)
            else:
                self.turnFromWall(nbr)                
                
        return True        

num_repeats = 1
for ii in range(num_repeats):

    my_mission_record = MalmoPython.MissionRecordSpec()

    # Attempt to start a mission:
    max_retries = 6
    for retry in range(max_retries):
        try:
            agent_host.startMission( my_mission, my_mission_record )
            break
        except RuntimeError as e:
            if retry == max_retries - 1:
                print("Error starting mission:", e)
                exit(1)
            else:
                print("Attempting to start the mission:")
                time.sleep(2)

    # Loop until mission starts:
    print("   Waiting for the mission to start")
    world_state = agent_host.getWorldState()

    while not world_state.has_mission_begun:
        print("\r"+hg.cursor(), end="")
        time.sleep(0.15)
        world_state = agent_host.getWorldState()
        for error in world_state.errors:
            print("Error:",error.text)

    print("NB4tf4i Red Flower Hell running\n")
    steve = Steve(agent_host)
    steve.run()
    print("Number of flowers: "+ str(steve.nof_red_flower))
    time.sleep(3)

print("Mission ended")
# Mission has ended.]]></programlisting>
        </para>
        <para>
            Az ágens felfelé halad csigamozgásban, diszkrét utasításokkal az arénában, és az érzékelt pipacsokat felszedi. Ideális esetben 19-et szed fel (nekem 16-nál nem tudott többet). 
            A végén kiírja az összeszedett virágok összegét.
        </para>
        <para>
            Létrehozunk egy Steve osztályt, majd definiáljuk azt: x,y,z koordináták, amik a világ koordinátái, a yaw-t, ami az érzékeléshez kell (ObservationFromGrid), valamint a pitch-et, 
            ami a fel-le nézéshez kell. Az utána következő adattagok a Steve körüli kockákat jelöli.  Ezután még definiáljuk a virágok számát, hogy mire néz, és az attacklvl-t. Ezek 
            értékét 0-ra állítjuk. Ezután tudatjuk az ágenssel, hogy hány virágot szedett eddig össze. A checkInventory-val az inventoryját tudja ellenőrizni: ha bekerül egy virág, akkor 
            azt kiírja, illetve ezzel követi nyomon, hogy melyik szinten szedte már össze a virágot. A pickUp segítségével szedi fel a virágot, az attack paranccsal. 
        </para>
        <para>
            A lvlUp-pal lép szintet, ezt, mindig akkor teszi, ha kiütötte és felvette a jelenlegi szinten lévő pipacsot. Ugrani a jumpmove paranccsal tud. Az isInTrap vizsgálja, hogy 
            belement-e valami csapdába Steve, pl. ha kiütötte maga alatt a földet, és nem tud simán továbbmenni (vagyis ha föld kockák fogják közre őt). Ezután következnek a fordulási 
            parancsok. A calcNbrIndex számolja a körülötte érzékelt kockákat (a tájékozódáshoz kell). A whatISee kiírja a terminálra, hogy mit érzékel maga körül. A whatMyPos lekérdezi a 
            saját pozícióját. (Elég beszédesek ezek a nevek, feleslegesnek érzem túlmagyarázni őket.)
        </para>
        <para>
            A def run(self) a lényegi része, ez hívódik meg a program indításakor. Steve megkapja az érzeteket, majd egy ciklus fut addig, amíg véget nem ér a küldetés (ha meghal, vagy 
            letelik a számláló). Ezután megnézi, hogy csapdában van-e, ha igen, akkor kiugrik onnan. Ha lát egy pipacsot, akkor kiírja a terminálra,  lenéz rá, és kiüti azt.  A for 
            ciklussal vizsgálja, hogy merre vannak virágok, ha érzékel egyet, akkor azt kiírja, ha rajta áll, akkor kiüti. Ezután szintet lép. Ha nem sikerül neki, akkor kiírja, hogy 
            akadályba ütközött, és próbál elfordulni. Ha nincs előtte akadály, akkor előre mozog tovább. 
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                