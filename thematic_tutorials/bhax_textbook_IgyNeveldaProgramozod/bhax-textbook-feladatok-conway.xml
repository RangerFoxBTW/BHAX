<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Mm1g9llfe7Q">https://youtu.be/Mm1g9llfe7Q</link>
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Conway/hangya/ant.h">ant.h</link>, <link xlink:href="src/Conway/hangya/antthread.cpp">antthread.cpp</link>, 
            <link xlink:href="src/Conway/hangya/antthread.h">antthread.h</link>, <link xlink:href="src/Conway/hangya/antwin.cpp">antwin.cpp</link>, 
            <link xlink:href="src/Conway/hangya/antwin.h">antwin.h</link>, <link xlink:href="src/Conway/hangya/main.cpp">main.cpp</link>, 
            <link xlink:href="src/Conway/hangya/myrmecologist.pro">myrmecologist.pro</link>               
        </para>
        <para>
            
        </para>            
    </section>  

    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_haXQEn1vGU">https://youtu.be/_haXQEn1vGU</link> 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="src/Conway/Sejtautomata.java">Sejtautomata.java</link>          
        </para>
        <para>
            John Conway, angol matematikus, a fejezet címadója az életjátékot. A neve megtévesztő, ugyanis nem klasszikus értelemben vett játék, sokkal inkább egyfajta szimuláció. Egy 
            négyzetrácsos terület reprezentálja az életteret, minden egyes cellában pedig sejtek jelenhetnek meg. 3 nagyon egyszerű szabállyal igen komplex szituációkat lehet kreálni. 
        </para>
        <para>
            A 3 szabály: Egy sejt 2 vagy 3 szomszéddal életben marad. Ha ennél kevesebb, vagy túlnépesedik (ennél több szomszédja van), akkor elpusztul. Egy sejt akkor születik, ha 
            pontosan 3 élő szomszédja van. Ezen felül különböző standard, dinamikus alakzatok jelenhetnek meg (a videóban igyekeztem szemléltetni párat). 
        </para>            
        <para>
            Ebben a feladatban egy siklókilövőt kell kreálni, ami minden körben folyamatosan létrehoz sejteket, és azokat kilövi az élettérbe. Ezen felül a Java-s implementációban 
            rajzolni is tudunk, így mi magunk is létrehozhatunk különböző sejteket. 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public class Sejtautomata extends java.awt.Frame implements Runnable {
    /** Egy sejt lehet élő */
    public static final boolean ÉLŐ = true;
    /** vagy halott */
    public static final boolean HALOTT = false;
    /** Két rácsot használunk majd, az egyik a sejttér állapotát
     * a t_n, a másik a t_n+1 időpillanatban jellemzi. */
    protected boolean [][][] rácsok = new boolean [2][][];
    /** Valamelyik rácsra mutat, technikai jellegű, hogy ne kelljen a
     * [2][][]-ból az első dimenziót használni, mert vagy az egyikre
     * állítjuk, vagy a másikra. */
    protected boolean [][] rács;
    /** Megmutatja melyik rács az aktuális: [rácsIndex][][] */
    protected int rácsIndex = 0;
    /** Pixelben egy cella adatai. */
    protected int cellaSzélesség = 20;
    protected int cellaMagasság = 20;
    /** A sejttér nagysága, azaz hányszor hány cella van? */
    protected int szélesség = 20;
    protected int magasság = 10;
    /** A sejttér két egymást követő t_n és t_n+1 diszkrét időpillanata
     közötti valós idő. */  
    protected int várakozás = 1000;
    // Pillanatfelvétel készítéséhez
    private java.awt.Robot robot;
    /** Készítsünk pillanatfelvételt? */
    private boolean pillanatfelvétel = false;
    /** A pillanatfelvételek számozásához. */
    private static int pillanatfelvételSzámláló = 0;
    /**
     * Létrehoz egy <code>Sejtautomata</code> objektumot.
     *
     * @param      szélesség    a sejttér szélessége.
     * @param      magasság     a sejttér szélessége.
     */
    public Sejtautomata(int szélesség, int magasság) {
        this.szélesség = szélesség;
        this.magasság = magasság;
        // A két rács elkészítése
        rácsok[0] = new boolean[magasság][szélesség];
        rácsok[1] = new boolean[magasság][szélesség];
        rácsIndex = 0;
        rács = rácsok[rácsIndex];
        // A kiinduló rács minden cellája HALOTT
        for(int i=0; i<rács.length; ++i)
            for(int j=0; j<rács[0].length; ++j)
                rács[i][j] = HALOTT;
        // A kiinduló rácsra "élőlényeket" helyezünk
        //sikló(rács, 2, 2);
        siklóKilövő(rács, 5, 60);
        // Az ablak bezárásakor kilépünk a programból.
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                setVisible(false);
                System.exit(0);
            }
        });]]></programlisting>
        </para>
        <para>
            Ez itt a konstruktor. A Kommentek és a változónevek magukért beszélnek. Érdekesség, hogy található itt egy Robot osztály, amit főleg alkalmazások tesztelésére használnak. Képes 
            kezelni a billentyűzet -és egérmegszakításokat.
        </para>
        <para>
            <programlisting language="java"><![CDATA[
// A billentyűzetről érkező események feldolgozása
        addKeyListener(new java.awt.event.KeyAdapter() {
            //A 'k', 'n', 'l', 'g' és 's' gombok lenyomását figyeljük
            public void keyPressed(java.awt.event.KeyEvent e) {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K) {
                    //Felezzük a cella méreteit:
                    cellaSzélesség /= 2;
                    cellaMagasság /= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N) {
                    //Duplázzuk a cella méreteit:
                    cellaSzélesség *= 2;
                    cellaMagasság *= 2;
                    setSize(Sejtautomata.this.szélesség*cellaSzélesség,
                            Sejtautomata.this.magasság*cellaMagasság);
                    validate();
                } else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_S)
                    pillanatfelvétel = !pillanatfelvétel;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    várakozás /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    várakozás *= 2;
                repaint();
            }
        });
        //Egérkattintó események feldolgozása:
        addMouseListener(new java.awt.event.MouseAdapter() {
            //Egérkattintással jelöljük ki a nagyítandó területet
            //Bal felső sarkát vagy ugyancsak egér kattintással
            //Vizsgáljuk egy adott pont iterációit:
            public void mousePressed(java.awt.event.MouseEvent m) {
                // Az egérmutató pozíciója
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = !rácsok[rácsIndex][y][x];
                repaint();
            }
        });
        //Egérmozgás események feldolgozása:
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            //Vonszolással jelöljük ki a négyzetet:
            public void mouseDragged(java.awt.event.MouseEvent m) {
                int x = m.getX()/cellaSzélesség;
                int y = m.getY()/cellaMagasság;
                rácsok[rácsIndex][y][x] = ÉLŐ;
                repaint();
            }
        });]]></programlisting>
        </para>
        <para>
            Ezek az eseménykezelő függvények, amelyek segítségével különböző funkciókat tudunk életrekelteni a program futtatása során. Az 's' karakter lenyomásával pillanatképet 
            készíthetünk, a 'k' lenyomásával kicsinyíteni tudjuk a világunkat, ezáltal nagyobb területet felfedve, az 'n' billentyűvel pedig nagyíthatunk rajta. A 'g' gombbal gyorsítani, 
            az 'l'-el pedig lassítani tudjuk a szimulációt. A kattintást, valamint a vonszolást is kezeljük, a kattintás helyén új sejt jön létre.
        </para>
        <para>
            <programlisting language="java"><![CDATA[
   /** A sejttér kirajzolása. */
    public void paint(java.awt.Graphics g) {
        //Az aktuális
        boolean [][] rács = rácsok[rácsIndex];
        //Rácsot rajzoljuk ki:
        for(int i=0; i<rács.length; i++) { //végig lépked a sorokon
            for(int j=0; j<rács[0].length; j++) { //s az oszlopok
                //Sejtcella kirajzolása
                if(rács[i][j] == ÉLŐ)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
                //Rács kirajzolása
                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzélesség, i*cellaMagasság,
                        cellaSzélesség, cellaMagasság);
            }
        }
        //Ha készült pillanatkép
        if(pillanatfelvétel) {
            /* a biztonság kedvéért egy kép készítése után
                kikapcsoljuk a pillanatfelvételt, hogy a
                programmal ismerkedő Olvasó ne írja tele a
                fájlrendszerét a pillanatfelvételekkel*/
            pillanatfelvétel = false;
            pillanatfelvétel(robot.createScreenCapture
                    (new java.awt.Rectangle
                    (getLocation().x, getLocation().y,
                    szélesség*cellaSzélesség,
                    magasság*cellaMagasság)));
        }
    }
    /**
      Az kérdezett állapotban lévő nyolcszomszédok száma.
    * 
    *    @param   rács    a sejttér rács
    *   @param   sor     a rács vizsgált sora
    *   @param   oszlop  a rács vizsgált oszlopa
    *    @param   állapor a nyolcszomszédok vizsgált állapota
    *    @return int a kérdezett állapotbeli nyolcszomszédok száma.
     */
    public int szomszédokSzáma(boolean [][] rács,
            int sor, int oszlop, boolean állapot) {        
        int állapotúSzomszéd = 0;
        // A nyolcszomszédok végigzongorázása:
        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)
                // A vizsgált sejtet magát kihagyva:
                if(!((i==0) && (j==0))) {
            // A sejttérből szélének szomszédai
            // a szembe oldalakon ("periódikus határfeltétel")
            int o = oszlop + j;
            if(o < 0)
                o = szélesség-1;
            else if(o >= szélesség)
                o = 0;
            
            int s = sor + i;
            if(s < 0)
                s = magasság-1;
            else if(s >= magasság)
                s = 0;
            
            if(rács[s][o] == állapot)
                ++állapotúSzomszéd;
                }
        
        return állapotúSzomszéd;
    }]]></programlisting>
        </para>
        <para>
            Berajzoljuk a fehér, illetve a fekete cellákat. Előbbi a halott, utóbbi az élő sejteket szimbolizálja. A SzomszédokSzáma függvényre azért van szükségünk, mert az algoritmus a 
            sejt élő szomszédjainak száma alapján működik. Kezeljük az olyan helyzeteket is, amikor a sejt egy szomszédja kilóg az élettérből (ilyenkor az átellenes pontban lévő sejtet 
            vizsgálja). 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public void időFejlődés() {
        
        boolean [][] rácsElőtte = rácsok[rácsIndex];
        boolean [][] rácsUtána = rácsok[(rácsIndex+1)%2];
        
        for(int i=0; i<rácsElőtte.length; ++i) { // sorok
            for(int j=0; j<rácsElőtte[0].length; ++j) { // oszlopok
                
                int élők = szomszédokSzáma(rácsElőtte, i, j, ÉLŐ);
                
                if(rácsElőtte[i][j] == ÉLŐ) {
                /* Élő élő marad, ha kettő vagy három élő
                 szomszedja van, különben halott lesz. */
                    if(élők==2 || élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }  else {
                /* Halott halott marad, ha három élő
                 szomszedja van, különben élő lesz. */
                    if(élők==3)
                        rácsUtána[i][j] = ÉLŐ;
                    else
                        rácsUtána[i][j] = HALOTT;
                }
            }
        }
        rácsIndex = (rácsIndex+1)%2;
    }
    /** A sejttér időbeli fejlődése. */
    public void run() {
        
        while(true) {
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
            
            időFejlődés();
            repaint();
        }
    }
    
    public void sikló(boolean [][] rács, int x, int y) {
        
        rács[y+ 0][x+ 2] = ÉLŐ;
        rács[y+ 1][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 1] = ÉLŐ;
        rács[y+ 2][x+ 2] = ÉLŐ;
        rács[y+ 2][x+ 3] = ÉLŐ;
        
    }]]></programlisting>
        </para>
        <para>
            Az életjáték szabályainak implementálása a kódba. Két négyzetrácsos élettérre lesz szükségünk, hiszen az elsőből alakítjuk ki a következő iterációban látható életteret. 
        </para>
        <para>
            <programlisting language="java"><![CDATA[
public void siklóKilövő(boolean [][] rács, int x, int y) {
        
        rács[y+ 6][x+ 0] = ÉLŐ;
        rács[y+ 6][x+ 1] = ÉLŐ;
        rács[y+ 7][x+ 0] = ÉLŐ;
        rács[y+ 7][x+ 1] = ÉLŐ;
        
        rács[y+ 3][x+ 13] = ÉLŐ;
        
        rács[y+ 4][x+ 12] = ÉLŐ;
        rács[y+ 4][x+ 14] = ÉLŐ;
        
        rács[y+ 5][x+ 11] = ÉLŐ;
        rács[y+ 5][x+ 15] = ÉLŐ;
        rács[y+ 5][x+ 16] = ÉLŐ;
        rács[y+ 5][x+ 25] = ÉLŐ;
        
        rács[y+ 6][x+ 11] = ÉLŐ;
        rács[y+ 6][x+ 15] = ÉLŐ;
        rács[y+ 6][x+ 16] = ÉLŐ;
        rács[y+ 6][x+ 22] = ÉLŐ;
        rács[y+ 6][x+ 23] = ÉLŐ;
        rács[y+ 6][x+ 24] = ÉLŐ;
        rács[y+ 6][x+ 25] = ÉLŐ;
        
        rács[y+ 7][x+ 11] = ÉLŐ;
        rács[y+ 7][x+ 15] = ÉLŐ;
        rács[y+ 7][x+ 16] = ÉLŐ;
        rács[y+ 7][x+ 21] = ÉLŐ;
        rács[y+ 7][x+ 22] = ÉLŐ;
        rács[y+ 7][x+ 23] = ÉLŐ;
        rács[y+ 7][x+ 24] = ÉLŐ;
        
        rács[y+ 8][x+ 12] = ÉLŐ;
        rács[y+ 8][x+ 14] = ÉLŐ;
        rács[y+ 8][x+ 21] = ÉLŐ;
        rács[y+ 8][x+ 24] = ÉLŐ;
        rács[y+ 8][x+ 34] = ÉLŐ;
        rács[y+ 8][x+ 35] = ÉLŐ;
        
        rács[y+ 9][x+ 13] = ÉLŐ;
        rács[y+ 9][x+ 21] = ÉLŐ;
        rács[y+ 9][x+ 22] = ÉLŐ;
        rács[y+ 9][x+ 23] = ÉLŐ;
        rács[y+ 9][x+ 24] = ÉLŐ;
        rács[y+ 9][x+ 34] = ÉLŐ;
        rács[y+ 9][x+ 35] = ÉLŐ;
        
        rács[y+ 10][x+ 22] = ÉLŐ;
        rács[y+ 10][x+ 23] = ÉLŐ;
        rács[y+ 10][x+ 24] = ÉLŐ;
        rács[y+ 10][x+ 25] = ÉLŐ;
        
        rács[y+ 11][x+ 25] = ÉLŐ;
        
    }
    /** Pillanatfelvételek készítése. */
    public void pillanatfelvétel(java.awt.image.BufferedImage felvetel) {
        // A pillanatfelvétel kép fájlneve
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("sejtautomata");
        sb.append(++pillanatfelvételSzámláló);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(felvetel, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
    // Ne villogjon a felület (mert a "gyári" update()
    // lemeszelné a vászon felületét).    
    public void update(java.awt.Graphics g) {
        paint(g);
    }    
    /**
     * Példányosít egy Conway-féle életjáték szabályos
     * sejttér obektumot.
     */    
    public static void main(String[] args) {
        // 100 oszlop, 75 sor mérettel:
        new Sejtautomata(100, 75);
    }
}]]></programlisting>
        </para>
        <para>
            A siklókilövőt sejtenként kirajzoljuk a rácsba. Ezután dinamikussá tesszük az által, hogy a mozgását  is beleégetjük a rácsba
        </para>
    </section>        

    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gSSqilLDih0">https://youtu.be/gSSqilLDih0</link>
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Conway/game/main.cpp">main.cpp</link>, <link xlink:href="src/Conway/game/sejtablak.cpp">sejtablak.cpp</link>, 
            <link xlink:href="src/Conway/game/sejtszal.cpp">sejtszal.cpp</link>, <link xlink:href="src/Conway/game/sejtablak.h">sejtablak.h</link>, <link xlink:href="src/Conway/game/sejtszal.h">sejtszal.h</link>, 
            <link xlink:href="src/Conway/game/Sejtauto.pro">Sejtauto.pro</link>               
        </para>
        <para>
            Érdekesség a játékról, hogy az 1970-es évek egyik legnagyobb vírusának tartották a játékot, ami megosztó volt a közönség számára.Voltak olyanok, akik napi szinten használták a 
            játékot, míg voltak olyanok, akik nem értették, mégis miért jó ez a játék, mi a szórakoztató abban, hogy csak figyelni lehet a képernyőt. Ebben az időben lényegében 
            "szenvedélybetegséggé" vált a játék, a Time becslése szerint pedig több millió dolláros anyagi kárt okozott a biztosítótársaságoknak és a bankoknak, hiszen ezzel a gépidőből 
            veszítettek. A kutatóintézetekben is mindenki az egymást követő generációkat figyelte a monitorokon, szinte megbénítva az életet.
        </para>            
        <para>  
            Mivel a program nagyon hasonló az előzőhöz viszonyítva, így erről kevesebb szót ejtenék. Itt nem lesz lehetőségünk az egérrel új sejteket létrehozni, valamint gyorsbillentyűket 
            sem tudunk használni extra funkciókhoz. Csak egy egyszerű siklókilövő.
        </para>
        <para>  
            A sejtablak.cpp-ben először megadjuk az ablak magasságát, a szélességét, a feliratot, a benne lévő cellák nagyságát (6x6), és két for ciklus használatával létrehozunk új 
            cellákat, és a paramétereket megadjuk minden cellának.
        </para>
        <para>  
            <programlisting language="c++"><![CDATA[
racsok = new bool**[2];
racsok[0] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
racsok[0][i] = new bool [szelesseg];
racsok[1] = new bool*[magassag];
for(int i=0; i<magassag; ++i)
racsok[1][i] = new bool [szelesseg];           
]]></programlisting>
        </para>
        <para>  
            Alapból minden cella fehér, tehát halott sejtek borítják. A paintEvent eljárás kirajzolja a cellákat 2 for ciklus segítségével, ha élő a sejt. Vagyis ha él, akkor feketére 
            színezi az adott cellát, ellenkező esetben fehér marad. Ebben a forráskódban található még az ablak törlése, valamint a sikló is, ami önmagát másolja, miközben halad a kilövés 
            irányába. A végén található maga a kilövő, aminek megjelenítésére az egyszerűség kedvéért előre megmondjuk, mely cellákat színezze be feketére, vagyis melyek legyenek élők.
        </para>
        <para>  
            A sejtszal.cpp-ben deklaráljuk a sejtszálat, valamint itt ellenőrizzük, hogy az adott sejtnek milyen szomszédai vannak. Végigmegyünk a szomszédokon és az oszlopszámhoz hozzáadunk/kivonunk
            1-et. Amennyiben negatív számot kapunk, az o változónk szélesség -1 lesz, ha pedig nagyobb, mint a szélességünk, akkor 0. Ezt megnézzük s-re is, és a kapott számokat betöltjük 
            az allapotuSzomszed változóba.
        </para>
        <para>  
            <programlisting language="c++"><![CDATA[
int allapotuSzomszed = 0;
for(int i=-1; i<2; ++i)
    for(int j=-1; j<2; ++j)
        if(!((i==0) && (j==0))) {
            int o = oszlop + j;
            if(o < 0)
                o = szelesseg-1;
            else if(o >= szelesseg)
                o = 0;

            int s = sor + i;
            if(s < 0)
                s = magassag-1;
            else if(s >= magassag)
                s = 0;
            if(racs[s][o] == allapot)
                allapotuSzomszed++;
}]]></programlisting>
        </para>
        <para>
            Az idoFejlodes eljárással végigmegyünk minden soron és oszlopon, megnézzük a rácsok szomszédjait és az élő sejt élő marad, ha kettő vagy három élő szomszédja van, egyébként 
            meghal. A halott halott marad, ha három élő szomszédja van, egyébként élővé válik. Ezután még deklaráljuk a run() eljárást, amiben egy végtelen ciklust használunk, hogy a 
            program örökké fusson, és az msleep használatával a várakozási időt felhasználva rávesszük a programot, hogy megfelelő időközönként frissítse az ablakot.
        </para>
    </section>    

    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/esport-talent-search">https://github.com/nbatfai/esport-talent-search</link>               
        </para>
        <para>
            A BrainB lényegében egy Benchmark program, amely az agy kognitív képességeit próbálja mérni. Az
            alapprobléma abból indult, hogy a legtöbb online kompetitív multiplayer játékban (különösen a
            MOBA-kban) gyakran előfordul, hogy egy teamfightban annyira sok vizuális tartalom jelenik meg a
            képernyőn egy időben, hogy egyszerűen nem tudjuk követni azokat, elveszítjük a karakterünket. A
            kognitív képességeink közé tartozik a szemünk által észlelt dolgok és események feldolgozása,
            azokból a hasznos információk leszűrése. Ezt a helyzetet igyekszik szimulálni a program.
        </para>    
        <para>
            A programot megnyitva különböző jelzésű négyzeteket láthatunk, mindegyikben egy sötét ponttal. A
            feladatunk az, hogy a Samu Entropy nevű négyzet pontjában tartsuk az egérmutatónkat lenyomva 10
            percig. Idő közben ezekből a négyzetekből egyre több lesz, valamint maguk az alakzatok
            mindeközben mozognak is (rezegnek/vibrálnak). Minél tovább tartjuk a helyes pontban az egerünket,
            annál több ilyen rezgő alakzat lesz látható a képernyőn, valamint egyre agresszívabban fogják a
            pozíciójukat változtatni. A 10 perc letelte után kapunk egy összesítő eredményjelző táblát, aminek az
            alján kiírja az agyam kognitív képességének a „számszerűsített” értékét Kbyte-ban. Alább látható az
            eredményem:
        </para>
        <para>
            <mediaobject>
                <imageobject>
                        <imagedata fileref="img/Conway/brainb.jpg" scale="35"/>
                </imageobject>
            </mediaobject>
        </para>        
    </section>        

    <section>
        <title>Minecraft MALMÖ Vörös Pipacs Pokol 19RF</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/VP0kfvRYD1Y">https://youtu.be/VP0kfvRYD1Y</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="src/Conway/pipacs.py">pipacs.py</link>
        </para>
        <para>
            
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                