<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Encoding</title>
        <para>Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
            fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
            <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link>
        </para>
		<para>
			Ebben a feladatban az egyetlen nehézség az volt, hogy meg kellett találni, hogy milyen karakterkódolást használtak a program írásakor, ezután csak a megfelelő kapcsolót kellett megkeresni ahhoz, hogy sikeresen lefordítsuk és futtassuk. 
		</para>
		<para>
			Az első elég könnyű volt, hiszen a legtöbb IDE és komolyabb szövegszerkesztő ezt automatikusan kijelzi nekünk. A második is egyszerű volt az én esetemben, még kapcsoló sem kellett hozzá. Ez úgy lehetséges, hogy az Ubuntu rendszerszinten automatikusan magyar nyelvi beállításokat használ. Vagyis UTF-8 karakterkódolást. Ezt a <command>locale</command> paranccsal könnyen ellenőrizhetjük. Azon ritka pillanatok egyike ez, amikor a egy Linux rendszer nem még egy akadályt gördít a felhasználó elé, hanem segít neki. Öröm volt látni!
		</para>
		<para>
			De ha esetleg nem magyar nyelvi beállításokat használunk, akkor se essünk pánikba! Az -encoding kapcsolóval bármilyen karakterkódolást megadhatunk fordításkor, így biztosan sikerrel járunk. Mivel ez magyar ékezetes latin karaktereket használ, így az ISO8859-2 karakterkódolás jó is lesz nekünk. Ez tartalmazza a legtöbb Közép-Európai nyelv karaktereit (cseh, szlovák, magyar, román stb.). Alább láthatjuk a program kimenetét.
		</para>
		<para>
			<mediaobject>
                <imageobject>
                        <imagedata fileref="img/Chomsky2/encoding.png" scale="50"/>
                </imageobject>
            </mediaobject>
		</para>
    </section>

    <section>
        <title>l3334d1c4</title>
        <para>
            Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű he-
lyettesítést: https://simple.wikipedia.org/wiki/Leet (Ha ez első részben nem tetted meg, akkor írasd ki és
magyarázd meg a használt struktúratömb memóriafoglalását!)
        </para>
    </section>

    <section>
        <title>Full screen</title>
        <para>
            Készítsünk egy teljes képernyős Java programot!
            Tipp: <link xlink:href="https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek">https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek</link>
        </para>  
		<para>
			Megoldás forrásai: <link xlink:href="src/Chomsky2/Display.java">Display.java</link>, <link xlink:href="src/Chomsky2/Screen.java">Screen.java</link>
		</para>
		<para>
			Ezt a feladatot kicsit megúszósra fogtam, hiszen a programom nem csinál mást, mint kiír egy szöveget teljes képernyős módban. A jövőben, ha lesz kedvem, majd átalakítom kicsit. De addig is nézzük a kódot. Swinget használtam, ami egy rettenetesen outdated tool Application fejlesztéshez, de az alapok megtanítására talán elég…
		</para>     
		<para>
			<programlisting language="java"><![CDATA[
import java.awt.*;
import javax.swing.JFrame;

public class Screen {
	
	private GraphicsDevice gd;
	
	public Screen() {
		GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
		gd = env.getDefaultScreenDevice();
	}]]></programlisting>
		</para>
		<para>
			A Screen osztály szolgál a teljes képernyős mód megjelenítéséért. Először importáljuk az abstract window toolkitet, valamint a JFrame-t. Ezek standard libraryk windowed/full screenes grafikus programok írásához Javaban. Az osztályon belül létrehozzuk a GraphicsDevice változót, ami lényegében a grafikus megjelenítő lesz. Ezután lekérdezzük a grafikus környezetet, majd az alapértelmezett megjelenítőt eltároljuk a gd-ben. 
		</para>
		<para>
            <programlisting language="java"><![CDATA[
public void setFullScreen(DisplayMode dm, JFrame window) {
		
		window.setUndecorated(true);
		window.setResizable(false);
		gd.setFullScreenWindow(window);
		
		if (dm != null && gd.isDisplayChangeSupported()) {
			try {
				gd.setDisplayMode(dm);
			}
			catch (Exception e){}
		}
	}
	
	public Window getFullScreenWindow() {
		return gd.getFullScreenWindow();
	}
	
	public void restore() {
		Window w = gd.getFullScreenWindow();
		if (w != null)
			w.dispose();
		gd.setFullScreenWindow(null);
	}
}]]></programlisting>
		</para>
		<para>
			A setFullScreen metódus fogja a proginkat teljes képernyőre rakni. Valójában a benne lévő setUndecorated(true) fogja ténylegesen eltávolítani az ablak kezelősávját felülről, így emiatt lesz full screen. Mellé még adjuk, hogy ne is lehessen átméretezni. Az if-ben azt vizsgáljuk, hogy van-e monitorbeállításunk, és azokat lehet-e állítani. A getFullScreenWindow fogja visszaadni a teljes képernyőt.  A restore metódus fog levenni a full screenről.
		</para>
		<para>
            <programlisting language="java"><![CDATA[
import java.awt.*;
import javax.swing.JFrame;

public class Display extends JFrame{
	
	public void run(DisplayMode dm) {
		getContentPane().setBackground(Color.cyan);
		getContentPane().setForeground(Color.black);
		getContentPane().setFont(new Font("Calibri", Font.BOLD, 100));

		Screen s = new Screen();
		try {
			s.setFullScreen(dm, this);
			try {
				Thread.sleep(3000);
			} catch (Exception e) {}
		} finally {
			s.restore();
		}
	}
	
	public void paint(Graphics g) {
		super.paint(g);
		g.drawString("Hello there!", 890, 530);
	}
		
	public static void main(String[] args) {
		DisplayMode dm = new DisplayMode(800, 600, 16, DisplayMode.REFRESH_RATE_UNKNOWN);	//Linux alatt kell szélesség, magasság, színmélység, képfrissítés
		Display d = new Display();
		d.run(dm);
	}
	
}]]></programlisting>
		</para>
		<para>
			A Display osztályunk fog ténylegesen dolgokat megjeleníteni a programban. Importáljuk a szükséges könyvtárakat (ha labeleket is szeretnénk, akkor a swingen belül a JLabel is kell, illetve az egérkattintás támogatásához az awt.event.*). Az osztályt kiterjesztjük a JFrame-re. A run metódusban állítjuk be a hátteret, betűtípust, betűszínt, méretet stb-t. Itt írtam egy try catch blokkot, ami azt szabályozza, hogy meddig maradjon full screenben a program (így kerültem meg, hogy használjam az egeret). A paint metódus segítségével fogunk a képernyőre írni (igazából sok dolgot lehet vele, képet beszúrni, ilyenek). Ezt a drawString-gel tesszük meg. Végül ebben az osztályban található a main, amiben a példányosítás történik. 
		</para>
		<para>
			<mediaobject>
                <imageobject>
                        <imagedata fileref="img/Chomsky2/Full.png" scale="50"/>
                </imageobject>
            </mediaobject>
		</para>
    </section>   

    <section>
        <title>EPAM: Bináris keresés és Buborék rendezés implementálása</title>
        <para>
            Implementálj egy Java osztályt, amely képes egy előre definiált n darab Integer tárolására. Ennek az
osztálynak az alábbi funkcionalitásokkal kell rendelkeznie: Elem hozzáadása a tárolt elemekhez, Egy tetszőleges Integer értékről tudja eldönteni, hogy már tároljuk-e (ehhez egy bináris keresőt
implementálj), A tárolt elemeket az osztályunk be tudja rendezni és a rendezett (pl növekvő sorrend) struktúrával
vissza tud térni (ehhez egy buborék rendezőt implementálj)
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Chomsky2/IntegerStorage.java">IntegerStorage.java</link>, <link xlink:href="src/Chomsky2/Main.java">Main.java</link>
        </para>
        <para>
            Egy klasszikus, kicsit gondolkodtató, de végtelenül élvezetes feladat. Kicsit mindenből kér a feladat, remek gyakorlófeladat azoknak, akik ismerkednek a Java nyelvvel, vagy épp az objektum-orientált programozással. Alább látható a megoldásom:
        </para>
        <para>
                <programlisting language="java"><![CDATA[
import java.util.Arrays;

public class IntegerStorage {
	
	private int[] s;
	private int index = 0;
	private int size;
	private boolean sorted = true;
	
	public IntegerStorage(int size) {
		this.size = size;
		this.s = new int[size];
	}
	
	public IntegerStorage(int[] s) {
		this.size = s.length;
		this.index = this.size;
		this.s = s;
		this.sorted = false;
	}]]></programlisting>
        </para>
        <para>
            Mivel tömbbel fogunk dolgozni, így a legelején importáljuk a java.util package-ből az Arrays osztályt. Ezután létrehozzuk az IntegerStorage osztályt, amiben dolgozni fogunk. Kezdésként létrehozzuk a használni kívánt attribútumainkat: egy tömböt, amiben tárolni tudjuk az elemeket, a tömb indexét, ami majd az elemek hozzáadásánál kell, kényelmi szempontból a tömb méretét is eltároljuk, illetve egy logikai változót, ami azt mondja majd meg, hogy a tömbünk rendezett-e. Ezek mind privát láthatóságúak az enkapszuláció érdekében. Ezalatt találhatóak a set metódusok, amik emiatt kellenek. Itt lényegében megmondjuk a fordítónak, hogy az osztály objektumaira referálunk a változónevekkel. Ezt a this kulcsszó segítségével tesszük meg.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public boolean binary(int number) {
		
		if (!sorted)
			bubble();
		
		int l = 0;
		int r = size - 1;
		
		while (l <= r) {
			int mid = l + (r - l) / 2;
			if (s[mid] == number)
				return true;
			if (s[mid] > number)
				r = mid -1;
			else
				l = mid + 1;
		}
		
		return false;
	}]]></programlisting>
        </para>
        <para>
            Ezután következik a bináris keresés implemetálása. tavaly tanultuk Adatszerkezetek órán, így nem sokat beszélnék róla. Mivel az adatszerkezetenek rendezettnek kell lennie, hogy bináris keresést hajtsunk végre rajta, így először ezt kell megvizsgálni. Ha nem rendezett, akkor meghívjuk a rendező eljárásunkat. Ezután jön maga a bináris keresés. Én az iteratív verziót írtam le, de van belőle rekurzív mód is. Megnézi, hogy a középső elem egyezik-e a keresett értékkel. ha igen, akkor azzal tér vissza. ha nem, akkor megvizsgálja, hogy a keresett elem nagyobb vagy kisebb-e a középsőnél. Ettől függően a középsőtől vagy balra vagy jobbra található részben keresi tovább az elemet. Ha nem találta meg, akkor hamis értékkel tér vissza.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public int[] bubble() {
		for (int i = 0; i < size; i++) {
			for (int j = 1; j < (size - i); j++) {
				if (s[j-1] > s[j]) {
					int t = s[j-1];
					s[j-1] = s[j];
					s[j] = t;
				}
			}
		}
		sorted = true;
		
		return s;
}

public void add(int number) {
    s[index++] = number;
    sorted = false;
}]]></programlisting>
        </para>
        <para>
            Ezután jön a buborékos rendezés, amiről szintén tanultunk már. Nem ez a leghatékonyabb rendezési algoritmus (sőt), de legalább könnyű implementálni. Egy segédváltozóval oldja meg az elemek cseréjét. Ha végbement, akkor a sorted logikai változó értékét igazra állítja, majd visszatér a rendezett tömbbel. Végül jön az add metódus, ami tömbhöz hozzáadja az elemeket. Nagyon egyszerű. Bővítés után természetesen a rendezettséget jelző logikai változót hamisra állítja.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
	@Override
	public String toString() {
		return "IntegerStorage [s=" + Arrays.toString(s) + ", index=" + index + ", size=" + size + ", sorted=" + sorted
				+ "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + index;
		result = prime * result + Arrays.hashCode(s);
		result = prime * result + size;
		result = prime * result + (sorted ? 1231 : 1237);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		IntegerStorage other = (IntegerStorage) obj;
		if (index != other.index)
			return false;
		if (!Arrays.equals(s, other.s))
			return false;
		if (size != other.size)
			return false;
		if (sorted != other.sorted)
			return false;
		return true;
	}
}]]></programlisting>
        </para>
        <para>
            A végén találhatóak az Override metódusok. Ezekről már egy korábbi fejezetben írtam, így nem térnék ki rájuk. Eclipse-ben pár kattintással létre lehet hozni őket, ami elég praktikus.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public class Main {

	public static void main(String[] args) {
		IntegerStorage store = new IntegerStorage(10);
		for (int i = 6; i < 13; i++) 
			store.add(i);
		store.add(5);
		store.add(3);
		store.add(1);
		
		store.bubble();
		System.out.println(store);
		System.out.println(store.binary(2));
		System.out.println(store.binary(7));
	}

}]]></programlisting>
        </para>
        <para>
            A Mainben történik a példányosítás, illetve írtam egy kis tesztet, amivel kipróbáltam, hogy minden működik-e. Alul látható a kimenet.
        </para>
        <para>
            <mediaobject>
                <imageobject>
                        <imagedata fileref="img/Chomsky2/int.png" scale="70"/>
                </imageobject>
            </mediaobject>
        </para>
    </section>
</chapter> 