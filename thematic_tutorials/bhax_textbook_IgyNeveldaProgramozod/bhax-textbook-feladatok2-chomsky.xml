<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    
    <section>
        <title>Encoding</title>
        <para>Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
            fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
            <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link>
        </para>
		<para>
			Ebben a feladatban az egyetlen nehézség az volt, hogy meg kellett találni, hogy milyen karakterkódolást használtak a program írásakor, ezután csak a megfelelő kapcsolót kellett megkeresni ahhoz, hogy sikeresen lefordítsuk és futtassuk. 
		</para>
		<para>
			Az első elég könnyű volt, hiszen a legtöbb IDE és komolyabb szövegszerkesztő ezt automatikusan kijelzi nekünk. A második is egyszerű volt az én esetemben, még kapcsoló sem kellett hozzá. Ez úgy lehetséges, hogy az Ubuntu rendszerszinten automatikusan magyar nyelvi beállításokat használ. Vagyis UTF-8 karakterkódolást. Ezt a <command>locale</command> paranccsal könnyen ellenőrizhetjük. Azon ritka pillanatok egyike ez, amikor a egy Linux rendszer nem még egy akadályt gördít a felhasználó elé, hanem segít neki. Öröm volt látni!
		</para>
		<para>
			De ha esetleg nem magyar nyelvi beállításokat használunk, akkor se essünk pánikba! Az -encoding kapcsolóval bármilyen karakterkódolást megadhatunk fordításkor, így biztosan sikerrel járunk. Mivel ez magyar ékezetes latin karaktereket használ, így az ISO8859-2 karakterkódolás jó is lesz nekünk. Ez tartalmazza a legtöbb Közép-Európai nyelv karaktereit (cseh, szlovák, magyar, román stb.). Alább láthatjuk a program kimenetét.
		</para>
		<para>
			<mediaobject>
                <imageobject>
                        <imagedata fileref="img/Chomsky2/encoding.png" scale="50"/>
                </imageobject>
            </mediaobject>
		</para>
    </section>

    <section>
        <title>l334d1c4</title>
        <para>
            Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
            helyettesítést: <link xlink:href="https://simple.wikipedia.org/wiki/Leet">https://simple.wikipedia.org/wiki/Leet</link>
        </para>
    </section>

    <section>
        <title>Full screen</title>
        <para>
            Készítsünk egy teljes képernyős Java programot!
            Tipp: <link xlink:href="https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek">https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek</link>
        </para>       
    </section>   

    <section>
        <title>EPAM: Bináris keresés és Buborék rendezés implementálása</title>
        <para>
            Implementálj egy Java osztályt, amely képes egy előre definiált n darab Integer tárolására. Ennek az
osztálynak az alábbi funkcionalitásokkal kell rendelkeznie: Elem hozzáadása a tárolt elemekhez, Egy tetszőleges Integer értékről tudja eldönteni, hogy már tároljuk-e (ehhez egy bináris keresőt
implementálj), A tárolt elemeket az osztályunk be tudja rendezni és a rendezett (pl növekvő sorrend) struktúrával
vissza tud térni (ehhez egy buborék rendezőt implementálj)
        </para>
        <para>
            Megoldás forrásai: <link xlink:href="src/Chomsky2/IntegerStorage.java">IntegerStorage.java</link>, <link xlink:href="src/Chomsky2/Main.java">Main.java</link>
        </para>
        <para>
            Egy klasszikus, kicsit gondolkodtató, de végtelenül élvezetes feladat. Kicsit mindenből kér a feladat, remek gyakorlófeladat azoknak, akik ismerkednek a Java nyelvvel, vagy épp az objektum-orientált programozással. Alább látható a megoldásom:
        </para>
        <para>
                <programlisting language="java"><![CDATA[
import java.util.Arrays;

public class IntegerStorage {
	
	private int[] s;
	private int index = 0;
	private int size;
	private boolean sorted = true;
	
	public IntegerStorage(int size) {
		this.size = size;
		this.s = new int[size];
	}
	
	public IntegerStorage(int[] s) {
		this.size = s.length;
		this.index = this.size;
		this.s = s;
		this.sorted = false;
	}]]></programlisting>
        </para>
        <para>
            Mivel tömbbel fogunk dolgozni, így a legelején importáljuk a java.util package-ből az Arrays osztályt. Ezután létrehozzuk az IntegerStorage osztályt, amiben dolgozni fogunk. Kezdésként létrehozzuk a használni kívánt attribútumainkat: egy tömböt, amiben tárolni tudjuk az elemeket, a tömb indexét, ami majd az elemek hozzáadásánál kell, kényelmi szempontból a tömb méretét is eltároljuk, illetve egy logikai változót, ami azt mondja majd meg, hogy a tömbünk rendezett-e. Ezek mind privát láthatóságúak az enkapszuláció érdekében. Ezalatt találhatóak a set metódusok, amik emiatt kellenek. Itt lényegében megmondjuk a fordítónak, hogy az osztály objektumaira referálunk a változónevekkel. Ezt a this kulcsszó segítségével tesszük meg.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public boolean binary(int number) {
		
		if (!sorted)
			bubble();
		
		int l = 0;
		int r = size - 1;
		
		while (l <= r) {
			int mid = l + (r - l) / 2;
			if (s[mid] == number)
				return true;
			if (s[mid] > number)
				r = mid -1;
			else
				l = mid + 1;
		}
		
		return false;
	}]]></programlisting>
        </para>
        <para>
            Ezután következik a bináris keresés implemetálása. tavaly tanultuk Adatszerkezetek órán, így nem sokat beszélnék róla. Mivel az adatszerkezetenek rendezettnek kell lennie, hogy bináris keresést hajtsunk végre rajta, így először ezt kell megvizsgálni. Ha nem rendezett, akkor meghívjuk a rendező eljárásunkat. Ezután jön maga a bináris keresés. Én az iteratív verziót írtam le, de van belőle rekurzív mód is. Megnézi, hogy a középső elem egyezik-e a keresett értékkel. ha igen, akkor azzal tér vissza. ha nem, akkor megvizsgálja, hogy a keresett elem nagyobb vagy kisebb-e a középsőnél. Ettől függően a középsőtől vagy balra vagy jobbra található részben keresi tovább az elemet. Ha nem találta meg, akkor hamis értékkel tér vissza.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public int[] bubble() {
		for (int i = 0; i < size; i++) {
			for (int j = 1; j < (size - i); j++) {
				if (s[j-1] > s[j]) {
					int t = s[j-1];
					s[j-1] = s[j];
					s[j] = t;
				}
			}
		}
		sorted = true;
		
		return s;
}

public void add(int number) {
    s[index++] = number;
    sorted = false;
}]]></programlisting>
        </para>
        <para>
            Ezután jön a buborékos rendezés, amiről szintén tanultunk már. Nem ez a leghatékonyabb rendezési algoritmus (sőt), de legalább könnyű implementálni. Egy segédváltozóval oldja meg az elemek cseréjét. Ha végbement, akkor a sorted logikai változó értékét igazra állítja, majd visszatér a rendezett tömbbel. Végül jön az add metódus, ami tömbhöz hozzáadja az elemeket. Nagyon egyszerű. Bővítés után természetesen a rendezettséget jelző logikai változót hamisra állítja.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
	@Override
	public String toString() {
		return "IntegerStorage [s=" + Arrays.toString(s) + ", index=" + index + ", size=" + size + ", sorted=" + sorted
				+ "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + index;
		result = prime * result + Arrays.hashCode(s);
		result = prime * result + size;
		result = prime * result + (sorted ? 1231 : 1237);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		IntegerStorage other = (IntegerStorage) obj;
		if (index != other.index)
			return false;
		if (!Arrays.equals(s, other.s))
			return false;
		if (size != other.size)
			return false;
		if (sorted != other.sorted)
			return false;
		return true;
	}
}]]></programlisting>
        </para>
        <para>
            A végén találhatóak az Override metódusok. Ezekről már egy korábbi fejezetben írtam, így nem térnék ki rájuk. Eclipse-ben pár kattintással létre lehet hozni őket, ami elég praktikus.
        </para>
        <para>
                <programlisting language="java"><![CDATA[
public class Main {

	public static void main(String[] args) {
		IntegerStorage store = new IntegerStorage(10);
		for (int i = 6; i < 13; i++) 
			store.add(i);
		store.add(5);
		store.add(3);
		store.add(1);
		
		store.bubble();
		System.out.println(store);
		System.out.println(store.binary(2));
		System.out.println(store.binary(7));
	}

}]]></programlisting>
        </para>
        <para>
            A Mainben történik a példányosítás, illetve írtam egy kis tesztet, amivel kipróbáltam, hogy minden működik-e. Alul látható a kimenet.
        </para>
        <para>
            <mediaobject>
                <imageobject>
                        <imagedata fileref="img/Chomsky2/int.png" scale="70"/>
                </imageobject>
            </mediaobject>
        </para>
    </section>
</chapter> 